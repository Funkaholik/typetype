// Generated by CoffeeScript 1.7.1
(function() {
  var $;

  ($ = jQuery).fn.extend({
    typetype: function(txt, keypress) {
      var error, interval, keyint;
      keyint = 100;
      error = 0.04;
      interval = function(i) {
        return Math.random() * keyint * (txt[i - 1] === txt[i] ? 1.6 : txt[i - 1] === '.' ? 12 : txt[i - 1] === '!' ? 12 : txt[i - 1] === '\n' ? 12 : txt[i - 1] === ',' ? 8 : txt[i - 1] === ';' ? 8 : txt[i - 1] === ' ' ? 3 : 2);
      };
      return this.each(function() {
        return $(this).queue(function() {
          var append, attr, backsp, elem, typeTo;
          elem = this;
          attr = elem.tagName === 'input'.toUpperCase() || elem.tagName === 'textarea'.toUpperCase() ? 'value' : 'innerHTML';
          append = function(str, cont) {
            if (str) {
              elem[attr] += str[0];
              setTimeout((function() {
                return append(str.slice(1), cont);
              }), keyint);
            } else {
              cont();
            }
          };
          backsp = function(num, cont) {
            if (num) {
              elem[attr] = elem[attr].slice(0, -1);
              setTimeout((function() {
                return backsp(num - 1, cont);
              }), keyint);
            } else {
              cont();
            }
          };
          return (typeTo = function(i) {
            var afterErr, len, r;
            if (len = txt.length >= i) {
              afterErr = function() {
                return setTimeout((function() {
                  return typeTo(i);
                }), interval(i));
              };
              r = Math.random();
              if (error * 0.3 > r && txt[i - 1] !== txt[i] && i + 4 < len) {
                append(txt.slice(i, i + 4), function() {
                  return backsp(4, afterErr);
                });
              } else if (error * 0.5 > r && txt[i - 1] !== txt[i] && i < len) {
                append(txt[i], function() {
                  return backsp(1, afterErr);
                });
              } else if (error * 0.8 > r && txt[i - 1] !== txt[i] && i < len) {
                append(txt[i] + txt[i - 1], function() {
                  return backsp(2, afterErr);
                });
              } else if (error * 1.0 > r && i > 1 && txt[i - 2] === txt[i - 2].toUpperCase() && i + 4 < len) {
                append(txt[i - 1].toUpperCase() + txt.slice(i, i + 4), function() {
                  return backsp(5, afterErr);
                });
              } else {
                elem[attr] += txt[i - 1];
                if (keypress) {
                  keypress.call(elem, i);
                }
                setTimeout((function() {
                  return typeTo(i + 1);
                }), interval(i));
              }
            } else {
              $(elem).dequeue();
            }
          })(1);
        });
      });
    }
  });

}).call(this);
